import { NextRequest, NextResponse } from "next/server";
import { auth } from "@clerk/nextjs/server";
import { z } from "zod";
import { prisma } from "@/lib/prisma";
import {
  ACTION_TOOLS,
  extractActionsFromToolCalls,
  processActions,
  ValidatedAction,
} from "@/lib/actions";
import { getAiContextForUser } from "@/lib/ai/userContext";
import {
  extractTraceContext,
  AIDebugEnvelopeBuilder,
  aiLogger,
  createRequestReceivedEvent,
  createModelCalledEvent,
  createActionsExtractedEvent,
  createResponseDeliveredEvent,
  createErrorEvent,
} from "@/lib/observability";
import { updateConversationStateFast } from "@/lib/conversation";
// Pipeline imports
import {
  runPipeline,
  createRunContext,
  PipelineStage,
  type CreateRunContextOptions,
} from "@/lib/pipeline";

const messageSchema = z.object({
  role: z.enum(["user", "assistant"]),
  content: z.string(),
});

const requestSchema = z.object({
  // Stable ID for this chat session (generated by client)
  // Used to persist rolling ConversationState in DB for later summarization on end.
  conversationId: z.string().min(1).max(128).optional(),
  verseReference: z.string().min(1),
  verseText: z.string().max(5000).optional(),
  conversationHistory: z.array(messageSchema).max(200),
  question: z.string().min(1).max(1000),
  initialContext: z
    .object({
      summary: z.string().optional(),
      historicalContext: z.string().optional(),
      crossReferences: z
        .array(
          z.object({
            ref: z.string(),
            note: z.string(),
          })
        )
        .optional(),
    })
    .optional(),
});

export async function POST(request: NextRequest) {
  const requestStartTime = Date.now();

  try {
    const { userId: clerkUserId } = await auth();
    if (!clerkUserId) {
      return new Response(JSON.stringify({ error: "Unauthorized" }), {
        status: 401,
        headers: { "Content-Type": "application/json" },
      });
    }

    // Extract trace context from request headers
    const traceCtx = extractTraceContext(request, clerkUserId);
    const envelope = new AIDebugEnvelopeBuilder(traceCtx);

    // Log request received event
    await aiLogger.event(
      createRequestReceivedEvent(
        traceCtx.traceId,
        traceCtx.requestId,
        traceCtx.entryPoint,
        traceCtx.userId,
        traceCtx.platform
      )
    );

    const body = await request.json();
    const validatedData = requestSchema.parse(body);

    // Set user message and verse context in envelope
    envelope.setUserMessage(validatedData.question);
    envelope.setVerseContext(
      validatedData.verseReference,
      validatedData.verseText
    );

    // Find our internal user
    const user = await prisma.user.findUnique({
      where: { clerkId: clerkUserId },
      select: { id: true },
    });

    if (!user) {
      return new Response(JSON.stringify({ error: "User not found" }), {
        status: 404,
        headers: { "Content-Type": "application/json" },
      });
    }

    // Get unified AI context
    const aiContext = await getAiContextForUser(user.id);

    // Check for debug mode headers
    const debugModeHeader = request.headers.get("x-debug-mode");
    const stopAtStageHeader = request.headers.get("x-stop-at-stage");
    const debugMode = debugModeHeader === "true";
    const stopAtStage = stopAtStageHeader as PipelineStage | undefined;

    // Create run context for the pipeline
    const contextOptions: CreateRunContextOptions = {
      traceId: traceCtx.traceId,
      userId: user.id,
      entrypoint: "followup",
      message: validatedData.question,
      entityRefs: [{
        type: "verse",
        reference: validatedData.verseReference,
        text: validatedData.verseText,
      }],
      mode: debugMode ? "debug" : "prod",
      stopAtStage: stopAtStage && Object.values(PipelineStage).includes(stopAtStage)
        ? stopAtStage
        : undefined,
      sideEffects: debugMode ? "disabled" : "enabled",
      writePolicy: debugMode ? "forbid" : "allow",
      appVersion: traceCtx.appVersion,
      platform: traceCtx.platform,
      conversationHistory: validatedData.conversationHistory,
      initialContext: validatedData.initialContext
        ? JSON.stringify(validatedData.initialContext)
        : undefined,
      aiContext: aiContext
        ? { userContext: aiContext as unknown as Record<string, unknown> }
        : undefined,
    };

    const ctx = createRunContext(contextOptions);

    // Run the pipeline
    const pipelineResult = await runPipeline(ctx);

    // If stopped early (debug mode), return artifacts
    if (pipelineResult.stoppedAt) {
      return NextResponse.json({
        runId: ctx.runId,
        stoppedAt: pipelineResult.stoppedAt,
        artifacts: pipelineResult.artifacts,
        _traceId: traceCtx.traceId,
      });
    }

    // Extract response from MODEL_CALL stage
    const modelCallArtifact = pipelineResult.artifacts.find(
      (a) => a.stage === PipelineStage.MODEL_CALL
    );

    if (!modelCallArtifact) {
      await aiLogger.event(
        createErrorEvent(
          traceCtx.traceId,
          traceCtx.requestId,
          "PipelineError",
          "No model call artifact found",
          "pipeline",
          false
        )
      );

      return NextResponse.json({
        error: "Pipeline completed but no response generated",
        runId: ctx.runId,
        artifacts: debugMode ? pipelineResult.artifacts : undefined,
        _traceId: traceCtx.traceId,
      }, { status: 500 });
    }

    const modelPayload = modelCallArtifact.payload as {
      responsePreview: string;
      toolTranscript: Array<{ name: string; args: Record<string, unknown>; success: boolean }>;
      latencyMs: number;
      inputTokens: number;
      outputTokens: number;
      finishReason: string;
      model: string;
    };

    // Persist rolling conversation state for this client chat session (best-effort)
    if (validatedData.conversationId) {
      await updateConversationStateFast(
        validatedData.conversationId,
        user.id,
        validatedData.question,
        modelPayload.responsePreview
      ).catch((err) => {
        console.error("[FollowUp] Failed to update conversation state:", err);
      });
    }

    // Log model call event
    await aiLogger.event(
      createModelCalledEvent(
        traceCtx.traceId,
        traceCtx.requestId,
        modelPayload.model,
        modelPayload.latencyMs,
        modelPayload.inputTokens,
        modelPayload.outputTokens,
        modelPayload.finishReason,
        modelPayload.toolTranscript.length
      )
    );

    // Set model call info in envelope
    envelope.setModelCall({
      model: modelPayload.model,
      temperature: 0.7,
      maxTokens: 500,
      latencyMs: modelPayload.latencyMs,
      inputTokens: modelPayload.inputTokens,
      outputTokens: modelPayload.outputTokens,
      finishReason: modelPayload.finishReason,
      toolCallsMade: modelPayload.toolTranscript.map((t) => t.name),
    });

    // Process actions from tool calls
    let validatedActions: ValidatedAction[] = [];
    let droppedActionsCount = 0;

    if (modelPayload.toolTranscript.length > 0) {
      // Extract actions from tool transcript.
      // Tool transcript entries are the executed tool calls with parsed args.
      // For suggest_actions, args should be { actions: RawAction[] } (ACTION_TOOLS schema).
      const rawActions = modelPayload.toolTranscript.flatMap((t) => {
        if (t.name !== "suggest_actions") return [];
        const maybeActions = (t.args as { actions?: unknown })?.actions;
        if (!Array.isArray(maybeActions)) return [];
        return maybeActions.filter((a): a is { type: string; params: Record<string, unknown>; confidence?: number } =>
          !!a && typeof a === "object" && !Array.isArray(a)
        );
      });

      const result = await processActions(rawActions, { userId: user.id });
      validatedActions = result.actions;
      droppedActionsCount = result.dropped.length;

      // Log actions extracted event
      await aiLogger.event(
        createActionsExtractedEvent(
          traceCtx.traceId,
          traceCtx.requestId,
          rawActions.length,
          validatedActions.length,
          droppedActionsCount,
          validatedActions.map((a) => a.type),
          Date.now() - requestStartTime
        )
      );

      // Set post-processing info in envelope
      envelope.setPostProcessing({
        actionsExtracted: validatedActions.map((a) => ({
          type: a.type,
          params: a.params,
          validated: true,
        })),
      });
    }

    const rawAnswer = modelPayload.responsePreview ?? "";
    const trimmedAnswer = rawAnswer.trim();
    const fallbackAnswer =
      "I didn’t generate a response just now. Could you try rephrasing your question in one sentence, or ask about a specific verse or section you’re reading?";
    const deliveredAnswer = trimmedAnswer.length > 0 ? rawAnswer : fallbackAnswer;

    // Set final response in envelope (what we actually delivered)
    envelope.setResponse(deliveredAnswer, "followup", validatedActions.length);

    // Log envelope and response delivered event
    await Promise.all([
      aiLogger.envelope(envelope.build()),
      aiLogger.event(
        createResponseDeliveredEvent(
          traceCtx.traceId,
          traceCtx.requestId,
          modelPayload.responsePreview.length,
          validatedActions.length,
          "followup",
          Date.now() - requestStartTime
        )
      ),
    ]);

    // Build response
    const response: Record<string, unknown> = {
      answer: deliveredAnswer,
      _traceId: traceCtx.traceId,
      _runId: ctx.runId,
    };

    // Useful for clients/debugging; safe to ignore if unknown.
    response._responseSource = (modelPayload as any).responseSource;
    response._fallbackUsed = trimmedAnswer.length === 0;

    if (validatedActions.length > 0) {
      response.actions = validatedActions;
    }

    // Include artifacts in debug mode
    if (debugMode) {
      response.artifacts = pipelineResult.artifacts;
      response._pipelineMode = true;
    }

    return NextResponse.json(response);
  } catch (error) {
    if (error instanceof z.ZodError) {
      if (process.env.NODE_ENV === "development") {
        console.error("Invalid request data:", error.issues);
      }

      return new Response(
        JSON.stringify({ error: "Invalid request data", details: error.issues }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }
    console.error("Error in followup endpoint:", error);
    return new Response(
      JSON.stringify({ error: "Failed to generate answer" }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
}
