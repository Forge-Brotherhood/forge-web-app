// -----------------------------
// Prisma Schema — Forge
// -----------------------------

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------- Enums ----------

enum GroupType {
  circle
  core
}

enum PrayerRequestStatus {
  open
  answered
  archived
}

enum PrayerEntryKind {
  request        // initial ask that seeds the request
  update         // progress update
  testimony      // fulfilled / praise report
  encouragement  // short notes, prayers, “standing with you”
  verse          // scripture card entry
  system         // system cards/prompts
}

enum AttachmentType {
  image
  video
  audio
}

enum PrayerResponseType {
  amen
  emoji
  verse_ref // lightweight “I dropped a verse ref here”
}

enum BanState {
  active
  banned
}

enum UploadStatus {
  uploading
  processing
  ready
  error
}

// ---------- Core ----------

model User {
  id              String   @id @default(uuid())
  clerkId         String   @unique
  email           String   @unique @db.Citext // enable extension: CREATE EXTENSION IF NOT EXISTS citext;
  firstName       String?
  lastName        String?
  displayName     String?
  handle          String?  @db.Citext        // add @unique if you want global handle uniqueness
  role            String   @default("user")
  banState        BanState @default(active)
  profileImageUrl String?
  voiceIntroUrl   String?
  prayerStreak    Int      @default(0)
  lastPrayerAt    DateTime?
  isSponsor       Boolean  @default(false)

  // Relations
  memberships              GroupMember[]
  prayerRequestsAuthored   PrayerRequest[] @relation("PrayerRequestAuthor")
  prayerEntriesAuthored    PrayerEntry[]   @relation("PrayerEntryAuthor")
  prayerResponses          PrayerResponse[]
  prayerActions            PrayerAction[]
  savedPrayers             SavedPrayer[]
  supports                 Support[]
  createdInvites           GroupInvite[]
  pushTokens               PushToken[]
  groupNotificationPrefs   GroupNotificationPreference[]

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  deletedAt  DateTime?

  @@index([handle])
}

model Group {
  id          String    @id @default(uuid())
  shortId     String    @unique // NanoID (10–12 chars), generate in app
  name        String?
  description String?
  groupType   GroupType @default(circle)

  // Relations
  members              GroupMember[]
  prayerRequests       PrayerRequest[]
  invites              GroupInvite[]
  notificationPrefs    GroupNotificationPreference[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?

  @@index([groupType])
  @@index([shortId])
}

model GroupMember {
  groupId  String
  userId   String
  status   String   @default("active") // active|pending|left
  role     String   @default("member") // member|leader
  joinedAt DateTime @default(now())

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Restrict)

  @@id([groupId, userId])
  @@index([userId])
}

model GroupInvite {
  id        String   @id @default(uuid())
  token     String   @unique  // NanoID (16 chars) - the share token
  groupId   String
  createdBy String
  expiresAt DateTime
  createdAt DateTime @default(now())

  group   Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  creator User  @relation(fields: [createdBy], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([groupId])
}

// ---------- Prayer Lifecycle ----------

model PrayerRequest {
  id                String               @id @default(uuid())
  shortId           String               @unique // NanoID (10–12 chars), generate in app
  groupId           String?
  authorId          String
  title             String?
  sharedToCommunity Boolean              @default(false)
  isAnonymous       Boolean              @default(false)
  status            PrayerRequestStatus  @default(open)

  // Denorm for performance / moderation
  lastActivityAt    DateTime             @default(now())
  postCount         Int                  @default(0)
  amenCount         Int                  @default(0)
  isHidden          Boolean              @default(false)
  reportedCount     Int                  @default(0)
  // moderationState String?             // optional future enum/string

  group  Group? @relation(fields: [groupId], references: [id], onDelete: SetNull)
  author User   @relation("PrayerRequestAuthor", fields: [authorId], references: [id], onDelete: Restrict)
  entries PrayerEntry[]
  actions PrayerAction[]
  savedBy SavedPrayer[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?

  @@index([groupId, status, lastActivityAt])
  @@index([sharedToCommunity, status, lastActivityAt])
  @@index([authorId, createdAt])
  @@index([shortId])
}

model PrayerEntry {
  id        String           @id @default(uuid())
  shortId   String           @unique // NanoID (10–12 chars), generate in app
  requestId String
  authorId  String?          // null for system entries
  kind      PrayerEntryKind  @default(request)
  content   String?

  // Optional denorms for UI badges / moderation
  amenCount     Int     @default(0)
  isHidden      Boolean @default(false)
  reportedCount Int     @default(0)

  request PrayerRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  author  User?         @relation("PrayerEntryAuthor", fields: [authorId], references: [id], onDelete: SetNull)
  attachments   Attachment[]
  responses     PrayerResponse[]
  actions       PrayerAction[]   // actions that targeted this entry
  savedBy       SavedPrayer[]    // saved items targeting this entry

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([requestId, kind, createdAt])
  @@index([authorId, createdAt])
  @@index([shortId])
}

model Attachment {
  id            String          @id @default(uuid())
  entryId       String?
  type          AttachmentType
  url           String
  width         Int?
  height        Int?
  durationS     Int?
  muxAssetId    String? @unique // webhook dedupe if applicable
  muxPlaybackId String? @unique // webhook dedupe if applicable
  uploadStatus  UploadStatus @default(ready)

  entry PrayerEntry? @relation(fields: [entryId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([entryId])
  @@index([url])
}

model PrayerResponse {
  id      String             @id @default(uuid())
  entryId String
  userId  String
  type    PrayerResponseType
  payload String             @default("") // avoid NULL-unique surprises

  entry PrayerEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)
  user  User        @relation(fields: [userId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())

  @@index([entryId])
  @@index([userId, createdAt])
  @@unique([entryId, userId, type, payload])
}

// ---------- Actions & Lists ----------

model PrayerAction {
  id        String   @id @default(uuid())
  userId    String
  requestId String
  entryId   String?

  /// Optional: if you want once-per-day-per-request semantics, set at write time
  actionDay DateTime? @db.Date

  user    User          @relation(fields: [userId], references: [id], onDelete: Restrict)
  request PrayerRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  entry   PrayerEntry?  @relation(fields: [entryId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([requestId, createdAt])
  @@index([entryId])
  // Uncomment if enforcing once-per-day-per-request:
  // @@unique([userId, requestId, actionDay])
}

model SavedPrayer {
  id        String   @id @default(uuid())
  userId    String
  requestId String
  entryId   String?  // nullable for whole-request saves

  user    User          @relation(fields: [userId], references: [id], onDelete: Restrict)
  request PrayerRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  entry   PrayerEntry?  @relation(fields: [entryId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@unique([userId, requestId, entryId])
  @@index([userId, createdAt])
  @@index([requestId])
  @@index([userId, requestId])
  // NOTE: For "one whole-request save per user", add a partial unique index in a SQL migration:
  // CREATE UNIQUE INDEX "SavedPrayer_user_request_nullentry_unique"
  // ON "SavedPrayer" ("userId", "requestId") WHERE "entryId" IS NULL;
}

// ---------- Stewardship ----------

model Support {
  id      String  @id @default(uuid())
  userId  String
  amount  Decimal @db.Decimal(12,2)
  active  Boolean @default(true)

  user User @relation(fields: [userId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, active])
}

// ---------- Push Notifications ----------

model PushToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  platform  String   // "ios" | "android" | "web"
  isActive  Boolean  @default(true)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([token])
}

model GroupNotificationPreference {
  id          String  @id @default(uuid())
  userId      String
  groupId     String
  pushEnabled Boolean @default(true)

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, groupId])
  @@index([userId])
  @@index([groupId])
}