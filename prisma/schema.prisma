// -----------------------------
// Prisma Schema — Forge
// -----------------------------

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ---------- Enums ----------

enum PrayerRequestStatus {
  open
  answered
  archived
}

enum PrayerEntryKind {
  request        // initial ask that seeds the request
  update         // progress update
  testimony      // fulfilled / praise report
  encouragement  // short notes, prayers, “standing with you”
  verse          // scripture card entry
  system         // system cards/prompts
}

enum AttachmentType {
  image
  video
  audio
}

enum PrayerResponseType {
  amen
  emoji
  verse_ref // lightweight “I dropped a verse ref here”
}

enum BanState {
  active
  banned
}

enum UploadStatus {
  uploading
  processing
  ready
  error
}

enum ReadingPlanVisibility {
  public
  private
  archived
}

enum UserReadingPlanStatus {
  scheduled
  active
  paused
  completed
  canceled
}

enum ReadingPlanReflectionKind {
  reflection
  self_prayer
}

// ---------- Core ----------

model User {
  id              String   @id @default(uuid())
  clerkId         String   @unique
  email           String   @unique @db.Citext // enable extension: CREATE EXTENSION IF NOT EXISTS citext;
  firstName       String?
  lastName        String?
  displayName     String?
  handle          String?  @db.Citext        // add @unique if you want global handle uniqueness
  role            String   @default("user")
  banState        BanState @default(active)
  profileImageUrl String?
  voiceIntroUrl   String?
  prayerStreak    Int      @default(0)
  lastPrayerAt    DateTime?
  isSponsor       Boolean  @default(false)

  // Relations
  prayerRequestsAuthored   PrayerRequest[] @relation("PrayerRequestAuthor")
  prayerEntriesAuthored    PrayerEntry[]   @relation("PrayerEntryAuthor")
  prayerResponses          PrayerResponse[]
  prayerActions            PrayerAction[]
  savedPrayers             SavedPrayer[]
  supports                 Support[]
  pushTokens               PushToken[]
  bibleHighlights          BibleHighlight[]
  verseNotes               VerseNote[]
  readerSettings           ReaderSettings?
  rollups                  UserRollup[]

  // Reading Plans relations
  createdTemplates          ReadingPlanTemplate[]   @relation("ReadingPlanTemplateCreator")
  userReadingPlans          UserReadingPlan[]       @relation("UserReadingPlans")
  readingPlanProgress       ReadingPlanProgress[]   @relation("ReadingPlanProgressUser")
  planReflections           ReadingPlanReflection[] @relation("ReadingPlanReflectionAuthor")

  // AI Memory & Preferences
  conversationStates        ConversationState[]
  chatSessions              ChatSession[]
  chatConversations         ChatConversation[] @relation("ChatConversationUser")
  chatSessionMemoryNotes    ChatSessionMemoryNote[] @relation("ChatSessionMemoryNoteUser")
  preferences               UserPreferences?
  lifeContext               UserLifeContext[]
  memoryState               UserMemoryState?

  // AI Debugger relations
  debugRunsAsAdmin          DebugRun[] @relation("DebugRunAdmin")
  debugRunsAsImpersonated   DebugRun[] @relation("DebugRunImpersonated")

  // Artifacts
  artifacts                 Artifact[]
  bibleReadingProgresses    BibleReadingProgress[]
  bibleReadingSessions      BibleReadingSession[]
  bibleReadingSessionSegments BibleReadingSessionSegment[]
  bibleChapterDailyRollups  BibleChapterDailyRollup[]

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  deletedAt  DateTime?

  @@index([handle])
}

// ---------- Prayer Lifecycle ----------

model PrayerRequest {
  id                String               @id @default(uuid())
  shortId           String               @unique // NanoID (10–12 chars), generate in app
  authorId          String
  title             String?
  sharedToCommunity Boolean              @default(false)
  isAnonymous       Boolean              @default(false)
  status            PrayerRequestStatus  @default(open)

  // Denorm for performance / moderation
  lastActivityAt    DateTime             @default(now())
  postCount         Int                  @default(0)
  amenCount         Int                  @default(0)
  isHidden          Boolean              @default(false)
  reportedCount     Int                  @default(0)
  // moderationState String?             // optional future enum/string

  author User   @relation("PrayerRequestAuthor", fields: [authorId], references: [id], onDelete: Restrict)
  entries PrayerEntry[]
  actions PrayerAction[]
  savedBy SavedPrayer[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  deletedAt DateTime?

  @@index([sharedToCommunity, status, lastActivityAt])
  @@index([authorId, createdAt])
  @@index([shortId])
}

model PrayerEntry {
  id        String           @id @default(uuid())
  shortId   String           @unique // NanoID (10–12 chars), generate in app
  requestId String
  authorId  String?          // null for system entries
  kind      PrayerEntryKind  @default(request)
  content   String?

  // Optional denorms for UI badges / moderation
  amenCount     Int     @default(0)
  isHidden      Boolean @default(false)
  reportedCount Int     @default(0)

  request PrayerRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  author  User?         @relation("PrayerEntryAuthor", fields: [authorId], references: [id], onDelete: SetNull)
  attachments   Attachment[]
  responses     PrayerResponse[]
  actions       PrayerAction[]   // actions that targeted this entry
  savedBy       SavedPrayer[]    // saved items targeting this entry

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([requestId, kind, createdAt])
  @@index([authorId, createdAt])
  @@index([shortId])
}

model Attachment {
  id            String          @id @default(uuid())
  entryId       String?
  type          AttachmentType
  url           String
  width         Int?
  height        Int?
  durationS     Int?
  muxAssetId    String? @unique // webhook dedupe if applicable
  muxPlaybackId String? @unique // webhook dedupe if applicable
  uploadStatus  UploadStatus @default(ready)

  entry PrayerEntry? @relation(fields: [entryId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([entryId])
  @@index([url])
}

model PrayerResponse {
  id      String             @id @default(uuid())
  entryId String
  userId  String
  type    PrayerResponseType
  payload String             @default("") // avoid NULL-unique surprises

  entry PrayerEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)
  user  User        @relation(fields: [userId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())

  @@index([entryId])
  @@index([userId, createdAt])
  @@unique([entryId, userId, type, payload])
}

// ---------- Actions & Lists ----------

model PrayerAction {
  id        String   @id @default(uuid())
  userId    String
  requestId String
  entryId   String?

  /// Optional: if you want once-per-day-per-request semantics, set at write time
  actionDay DateTime? @db.Date

  user    User          @relation(fields: [userId], references: [id], onDelete: Restrict)
  request PrayerRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  entry   PrayerEntry?  @relation(fields: [entryId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([requestId, createdAt])
  @@index([entryId])
  // Uncomment if enforcing once-per-day-per-request:
  // @@unique([userId, requestId, actionDay])
}

model SavedPrayer {
  id        String   @id @default(uuid())
  userId    String
  requestId String
  entryId   String?  // nullable for whole-request saves

  user    User          @relation(fields: [userId], references: [id], onDelete: Restrict)
  request PrayerRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)
  entry   PrayerEntry?  @relation(fields: [entryId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@unique([userId, requestId, entryId])
  @@index([userId, createdAt])
  @@index([requestId])
  @@index([userId, requestId])
  // NOTE: For "one whole-request save per user", add a partial unique index in a SQL migration:
  // CREATE UNIQUE INDEX "SavedPrayer_user_request_nullentry_unique"
  // ON "SavedPrayer" ("userId", "requestId") WHERE "entryId" IS NULL;
}

// ---------- Stewardship ----------

model Support {
  id      String  @id @default(uuid())
  userId  String
  amount  Decimal @db.Decimal(12,2)
  active  Boolean @default(true)

  user User @relation(fields: [userId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, active])
}

// ---------- Push Notifications ----------

model PushToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  platform  String   // "ios" | "android" | "web"
  isActive  Boolean  @default(true)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([token])
}

// ---------- Bible Highlights ----------

model BibleHighlight {
  id        String   @id @default(uuid())
  userId    String
  bookId     String   // API.Bible book code (e.g., "JHN")
  chapter    Int
  verseStart Int
  verseEnd   Int
  color      String   // yellow, green, blue, pink, orange
  bibleVersion String  @default("BSB")

  // Link to canonical Artifact row (metadata-only)
  artifactId String?  @unique
  artifact   Artifact? @relation("BibleHighlightArtifact", fields: [artifactId], references: [id], onDelete: SetNull)

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Optional linkage to reading plan (highlight made during plan)
  userPlanId    String?
  userPlan      UserReadingPlan? @relation(fields: [userPlanId], references: [id], onDelete: SetNull)
  templateDayId String?
  templateDay   ReadingPlanTemplateDay? @relation(fields: [templateDayId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, bookId, chapter, verseStart, verseEnd])
  @@index([userId, bookId, chapter])
  @@index([userPlanId, templateDayId])
}

// ---------- Bible Notes ----------

model VerseNote {
  id        String   @id @default(uuid())
  userId    String
  // Anchor verse (kept for backwards compatibility). For range notes, this is the start verse.
  // Format: "GEN_1_1" (bookId_chapter_verse)
  verseId   String
  bookId     String   // API.Bible book code (e.g., "JHN")
  chapter    Int
  verseStart Int
  verseEnd   Int
  content   String   // Note text (max 2000 chars enforced at API level)
  isPrivate Boolean  @default(false)  // If true, only author can see

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Optional linkage to reading plan (note made during plan)
  userPlanId    String?
  userPlan      UserReadingPlan? @relation(fields: [userPlanId], references: [id], onDelete: SetNull)
  templateDayId String?
  templateDay   ReadingPlanTemplateDay? @relation(fields: [templateDayId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([verseId])
  @@index([bookId, chapter])
  @@index([userId, bookId, chapter])
  @@index([userId])
  @@index([isPrivate])
  @@index([userPlanId, templateDayId])
}

// ---------- Reader Settings ----------

model ReaderSettings {
  id                    String   @id @default(uuid())
  userId                String   @unique
  fontSize              Float    @default(19)
  fontType              String   @default("serif")
  lineSpacing           String   @default("normal")
  theme                 String   @default("light")
  showWordsOfJesusInRed Boolean  @default(true)
  lastHighlightColor    String   @default("yellow")
  highlightColorOrder   String[] @default(["yellow", "green", "blue", "pink", "orange"])
  selectedTranslation   String   @default("BSB")
  hiddenNoteGroups      String[] @default([])  // Group IDs whose notes should be hidden

  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
}

// ---------- Bible Reading Progress (Free Reading) ----------

model BibleReadingProgress {
  id            String   @id @default(uuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Location
  bookId        String   // e.g. "GEN"
  bookName      String?  // optional display cache from client
  chapterId     String?  // optional API.Bible chapter ID
  chapter       Int
  verse         Int
  translation   String   // e.g. "BSB"

  // How the user entered (standalone, plan, search, etc.)
  contextType     String   @default("standalone")
  contextSourceId String?

  // Optional UI state for precise resume
  uiState       Json?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([userId, bookId])
  @@index([userId, updatedAt])
}

model BibleReadingSession {
  id            String   @id @default(uuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Client-generated session id (UUID string)
  sessionId     String

  // Session timing/metrics
  startedAt          DateTime
  endedAt            DateTime
  durationSeconds    Int
  source             String   @default("ios")

  // How the user entered (standalone, plan, search, etc.)
  contextType     String   @default("standalone")
  contextSourceId String?
  entryPoint      String?

  segments      BibleReadingSessionSegment[]

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([userId, sessionId])
  @@index([userId, endedAt])
}

model BibleReadingSessionSegment {
  id            String   @id @default(uuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  sessionId     String
  session       BibleReadingSession @relation(fields: [userId, sessionId], references: [userId, sessionId], onDelete: Cascade)

  // Client-generated segment id (UUID string) for idempotency/dedupe.
  segmentId     String

  // Location
  bookId        String
  bookName      String?
  chapterId     String?
  chapter       Int
  translation   String

  // Segment timing/metrics
  startedAt          DateTime
  endedAt            DateTime
  durationSeconds    Int
  readRanges         String[]
  source             String   @default("ios")

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([userId, segmentId])
  @@index([userId, sessionId, endedAt])
  @@index([userId, sessionId, bookId, chapter])
}

model BibleChapterDailyRollup {
  id            String   @id @default(uuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  bookId        String
  bookName      String?
  chapterId     String?
  chapter       Int
  translation   String

  durationSeconds    Int      @default(0)
  completionStatus   Json?
  readRanges         String[]

  // Temporal bucket (user-local)
  localDate     String   // YYYY-MM-DD in user-local timezone
  timeZone      String   // IANA timezone (e.g. America/Los_Angeles) from client
  firstReadAt   DateTime?
  lastReadAt    DateTime?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([userId, bookId, chapter, localDate])
  @@index([userId, lastReadAt])
  @@index([userId, bookId, chapter])
}

// ---------- Reading Plans ----------

model ReadingPlanTemplate {
  id            String   @id @default(uuid())
  shortId       String   @unique // NanoID (10 chars)
  slug          String   @unique // e.g. "romans-gospel-changes-everything"

  title         String
  subtitle      String?
  description   String?
  coverImageUrl String?

  totalDays           Int
  estimatedMinutesMin Int @default(7)
  estimatedMinutesMax Int @default(12)
  theme               String?

  visibility  ReadingPlanVisibility @default(public)
  isPublished Boolean               @default(false)
  isFeatured  Boolean               @default(false)

  createdById String?
  createdBy   User?   @relation("ReadingPlanTemplateCreator", fields: [createdById], references: [id], onDelete: SetNull)

  days        ReadingPlanTemplateDay[]
  userPlans   UserReadingPlan[]
  embeddings  ReadingPlanTemplateEmbedding[]

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  @@index([visibility, isPublished])
  @@index([createdById])
  @@index([slug])
}

model ReadingPlanTemplateDay {
  id          String              @id @default(uuid())
  templateId  String
  template    ReadingPlanTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  dayNumber   Int  // 1-indexed (Day 1, Day 2, etc.)

  // Scripture reference - structured format for non-contiguous ranges
  // Each block: { bookId, chapter, startVerse?, endVerse?, order }
  scriptureBlocks  Json     // Array of ScriptureBlock objects
  passageRef       String   // Auto-generated from scriptureBlocks: "1 Samuel 17:1-11, 32-50"

  title          String?  // "Faith Over Performance"
  summary        String?  // Brief description for daily card

  reflectionPrompt String? // "What stood out to you today?"
  prayerPrompt     String? // "Pray for one brother's faith today."

  contextIntro   String?  // Historical/cultural context
  extraMetadata  Json?    // Future: tags, video refs, etc.

  audioUrl       String?  // Cloudinary URL for narration audio

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations for progress/reflections
  progress      ReadingPlanProgress[]
  reflections   ReadingPlanReflection[]
  highlights    BibleHighlight[]
  notes         VerseNote[]
  scriptureAudio ReadingPlanDayAudio?

  @@unique([templateId, dayNumber])
  @@index([templateId])
}

// Unified day audio with section and verse-level timestamps for navigation
model ReadingPlanDayAudio {
  id            String @id @default(uuid())
  templateDayId String @unique
  templateDay   ReadingPlanTemplateDay @relation(fields: [templateDayId], references: [id], onDelete: Cascade)

  translation   String   // "BSB" - which translation's text was used
  voiceId       String   // ElevenLabs voice ID
  audioUrl      String   // Cloudinary URL for unified day audio
  durationMs    Int      // Total duration in milliseconds

  // Unified markers array (sections + verses)
  // [{ type: "section", id: "title", label: "Title", startMs: 0, endMs: 5000 },
  //  { type: "verse", id: "ROM.8.1", label: "v1", startMs: 25000, endMs: 30000 }, ...]
  markers       Json

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([templateDayId])
}

model UserReadingPlan {
  id          String @id @default(uuid())
  shortId     String @unique // NanoID (10 chars)

  userId      String
  user        User   @relation("UserReadingPlans", fields: [userId], references: [id], onDelete: Cascade)

  templateId  String
  template    ReadingPlanTemplate @relation(fields: [templateId], references: [id], onDelete: Restrict)

  // Scheduling
  startDate   DateTime  // When Day 1 begins
  status      UserReadingPlanStatus @default(scheduled)

  // Optional configuration
  notifyDaily Boolean  @default(true)
  timezone    String   @default("America/New_York")

  progress    ReadingPlanProgress[]
  reflections ReadingPlanReflection[]
  highlights  BibleHighlight[]
  notes       VerseNote[]

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?

  @@index([userId, status])
  @@index([templateId])
  @@index([startDate])
}

model ReadingPlanProgress {
  id              String           @id @default(uuid())

  userPlanId      String
  userPlan        UserReadingPlan @relation(fields: [userPlanId], references: [id], onDelete: Cascade)

  templateDayId   String
  templateDay     ReadingPlanTemplateDay @relation(fields: [templateDayId], references: [id], onDelete: Cascade)

  userId          String
  user            User @relation("ReadingPlanProgressUser", fields: [userId], references: [id], onDelete: Cascade)

  // Step completion flags
  hasRead         Boolean   @default(false)
  hasReflected    Boolean   @default(false)
  hasPrayed       Boolean   @default(false)
  completedAt     DateTime?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([userPlanId, templateDayId, userId])
  @@index([userId])
  @@index([userPlanId, templateDayId])
}

model ReadingPlanReflection {
  id            String @id @default(uuid())

  userPlanId    String
  userPlan      UserReadingPlan @relation(fields: [userPlanId], references: [id], onDelete: Cascade)

  templateDayId String
  templateDay   ReadingPlanTemplateDay @relation(fields: [templateDayId], references: [id], onDelete: Cascade)

  userId        String
  user          User @relation("ReadingPlanReflectionAuthor", fields: [userId], references: [id], onDelete: Cascade)

  kind          ReadingPlanReflectionKind @default(reflection)

  content       String?   // Text reflection/prayer
  audioUrl      String?   // Future: audio reflections

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userPlanId, templateDayId])
  @@index([userId])
}

// ---------- AI Memory ----------

/// User preferences for AI personalization and app behavior
/// Source of truth for all user preferences (synced from iOS onboarding)
model UserPreferences {
  id                String   @id @default(cuid())
  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Identity
  displayName       String?                           // How they want to be addressed

  // Bible preferences
  translationId     String   @default("BSB")          // BSB, ESV, NIV, etc.

  // AI interaction style
  explanationStyle    String   @default("balanced")     // gentle | balanced | deep | questions
  experienceLevel     String   @default("growing")      // new | growing | mature | scholar
  encouragementStyle  String   @default("gentle")       // direct | gentle | challenge | questions

  // Study intent (from onboarding - what they hope to find)
  studyIntent       String[] @default([])             // ["peace", "understanding", "encouragement", "guidance"]

  // Memory/privacy
  memoryMode        String   @default("standard")     // off | minimal | standard | full

  // Versioning for future migrations
  schemaVersion     Int      @default(1)

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

/// Rolling conversation state (replaces compactor.ts)
model ConversationState {
  id              String   @id @default(cuid())
  conversationId  String   @unique
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Rolling summary of conversation history
  summary         String   @db.Text

  // Recent messages for immediate context (array of { role, content, timestamp })
  recentMessages  Json

  // OpenAI Responses API session pointer for chaining across turns
  previousResponseId String?

  // Session-scoped personalization notes (captured during chat, consolidated on session end)
  // Array of { text: string, keywords?: string[], createdAtISO?: string }
  sessionMemoryNotes Json?

  // Metadata
  turnCount       Int      @default(0)
  lastSummaryAt   DateTime @default(now())

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId])
}

/// Minimal managed conversation pointer for the Guide assistant.
/// Stores OpenAI Responses API chaining pointer and metadata about how the user entered the conversation.
model ChatConversation {
  id               String   @id @default(cuid())
  conversationId   String   @unique
  userId           String
  user             User     @relation("ChatConversationUser", fields: [userId], references: [id], onDelete: Cascade)

  /// Surface that initiated the conversation (e.g. "bible_reader", "home", "community", "other")
  entrypoint       String   @default("other")

  /// Context emphasis for the assistant (e.g. "general" | "bible")
  mode             String   @default("general")

  /// OpenAI Responses API session pointer for chaining across turns (deprecated, use openaiConversationId)
  previousResponseId String?

  /// OpenAI Conversations API ID for persistent conversation state (e.g. "conv_xxxxx")
  openaiConversationId String?

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  notes            ChatSessionMemoryNote[]

  @@index([userId])
  @@index([userId, updatedAt])
}

/// Session-scoped memory notes captured during a chat, with optional TTL.
/// Consolidated into durable memory on chat end.
model ChatSessionMemoryNote {
  id             String   @id @default(cuid())
  conversationId String
  conversation   ChatConversation @relation(fields: [conversationId], references: [conversationId], onDelete: Cascade)

  userId         String
  user           User     @relation("ChatSessionMemoryNoteUser", fields: [userId], references: [id], onDelete: Cascade)

  text           String   @db.Text
  keywords       String[] @default([])

  expiresAt      DateTime?

  createdAt      DateTime @default(now())

  @@index([userId, createdAt])
  @@index([conversationId, createdAt])
  @@index([expiresAt])
}

// ---------- Chat Sessions (Transcript Storage) ----------

/// Durable chat session metadata for AI chats (Guide + Bible).
/// Stores list-friendly data (3–5 word title, endedAt) and links to full transcript messages.
model ChatSession {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Client conversation/session identifier (iOS conversationId)
  sessionId  String

  // "guide" | "bible"
  kind       String

  // 3–5 word title for history list
  title      String

  // OpenAI Conversations API ID for restoring conversation context (e.g. "conv_xxxxx")
  openaiConversationId String?

  startedAt  DateTime @default(now())
  endedAt    DateTime

  messages   ChatMessage[]

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([userId, kind, sessionId])
  @@index([userId, kind, endedAt])
  @@index([sessionId])
}

model ChatMessage {
  id            String      @id @default(cuid())
  chatSessionId String
  chatSession   ChatSession @relation(fields: [chatSessionId], references: [id], onDelete: Cascade)

  // "user" | "assistant"
  role          String
  content       String      @db.Text
  actions       Json?

  // Preserve client ordering if needed (ISO string). createdAt is canonical for ordering.
  clientTimestamp String?

  createdAt     DateTime @default(now())

  @@index([chatSessionId, createdAt])
}

/// State-based memory store (cookbook-style) for durable personalization notes.
/// Session-scoped notes live on ConversationState.sessionMemoryNotes and are consolidated on chat end.
model UserMemoryState {
  id            String   @id @default(cuid())
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  schemaVersion String   @default("forge.user_memory_state.v1")

  /// Global durable memory notes (array of { text, keywords, createdAtISO, expiresAtISO? }).
  /// `expiresAtISO` is generally omitted for global notes; TTL notes are session-scoped.
  globalNotes   Json

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId])
}

/// Life context for pastoral personalization (time-scoped, user-approved)
model UserLifeContext {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Context type
  type          String                              // schedule | season | prayer_topic | weekly_intention | goal

  // Structured value (type-specific JSON)
  value         Json                                // { season: "anxious" } or { carrying: "...", hoping: "..." }

  // Visibility and consent
  source        String   @default("user_entered")   // user_entered | user_confirmed
  visibility    String   @default("private")        // private | group_shareable

  // Time bounding
  expiresAt     DateTime?                           // null = permanent (goals)
  pinnedUntil   DateTime?                           // User explicitly kept this longer

  // Check-in scheduling
  checkInAt     DateTime?                           // Optional reminder to follow up
  lastCheckedIn DateTime?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId])
  @@index([userId, type])
  @@index([expiresAt])
}

// ---------- Artifacts ----------

/// User content artifacts with retrieval and relationship support
model Artifact {
  id              String    @id @default(cuid())
  userId          String?
  conversationId  String?   // if derived from chat
  sessionId       String?   // if derived from a session

  // Classification
  type            String    // conversation_session_summary | journal_entry | prayer_request | prayer_update | testimony | verse_highlight | verse_note
  scope           String    // private | global
  title           String?   // optional display label
  content         String    @db.Text

  // Retrieval helpers
  scriptureRefs   Json?     // e.g. ["Romans 8:1-11"]
  tags            Json?     // controlled tags
  metadata        Json?     // flexible fields

  // Lifecycle
  status          String    @default("active") // active | deleted
  deletedAt       DateTime?

  user            User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
  embeddings      ArtifactEmbedding[]
  edgesFrom       ArtifactEdge[] @relation("EdgeFrom")
  edgesTo         ArtifactEdge[] @relation("EdgeTo")
  bibleHighlight  BibleHighlight? @relation("BibleHighlightArtifact")

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([userId, type, createdAt])
  @@index([sessionId])
  @@index([status, createdAt])
}

/// Relationships between artifacts (threads, follow-ups, references)
model ArtifactEdge {
  id          String   @id @default(cuid())
  fromId      String
  toId        String
  relation    String   // follows_up | summarizes | references | part_of_thread

  from        Artifact @relation("EdgeFrom", fields: [fromId], references: [id], onDelete: Cascade)
  to          Artifact @relation("EdgeTo", fields: [toId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())

  @@index([fromId, relation])
  @@index([toId, relation])
}

/// Model-versioned embeddings for semantic search
model ArtifactEmbedding {
  id          String   @id @default(cuid())
  artifactId  String
  model       String   // e.g. "text-embedding-3-small"
  dimension   Int
  vector      Bytes    // serialized float array

  artifact    Artifact @relation(fields: [artifactId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())

  @@unique([artifactId, model])
  @@index([model])
}

/// Embeddings for reading plan templates (public plans searchable by Guide)
model ReadingPlanTemplateEmbedding {
  id          String   @id @default(cuid())
  templateId  String
  model       String   // e.g. "text-embedding-3-small"
  dimension   Int
  vector      Bytes    // serialized float array

  template    ReadingPlanTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())

  @@unique([templateId, model])
  @@index([model])
}

// ---------- AI Pipeline ----------

/// Pipeline stage artifacts for debugging and observability
model PipelineArtifact {
  id              String   @id @default(cuid())
  runId           String
  traceId         String
  userId          String
  stage           String                              // INGRESS | CONTEXT_CANDIDATES | RANK_AND_BUDGET | PROMPT_ASSEMBLY | MODEL_CALL
  schemaVersion   String                              // Version of the payload schema
  pipelineVersion String                              // Version of the pipeline
  summary         String                              // Human-readable summary
  payload         Json                                // Redacted stage output
  rawRef          String?                             // Vault pointer: "vault://<runId>/<stage>"
  stats           Json                                // Stage statistics
  durationMs      Int                                 // Stage execution time
  createdAt       DateTime @default(now())
  expiresAt       DateTime                            // Auto-cleanup after expiry

  @@unique([runId, stage])
  @@index([traceId])
  @@index([userId, createdAt])
  @@index([expiresAt])
}

/// Encrypted vault for raw content (debug mode only)
model PipelineVault {
  id               String   @id @default(cuid())
  runId            String
  stage            String
  encryptedContent String   @db.Text                  // AES-256-GCM encrypted JSON
  iv               String                              // Initialization vector
  authTag          String                              // GCM authentication tag
  createdAt        DateTime @default(now())
  expiresAt        DateTime

  @@unique([runId, stage])
  @@index([expiresAt])
}

// ---------- AI Debugger ----------

enum DebugRunStatus {
  pending
  running
  stopped
  completed
  error
}

/// Admin debug runs for pipeline inspection with user impersonation
model DebugRun {
  id                  String         @id @default(cuid())
  runId               String         @unique   // Links to PipelineArtifact.runId
  traceId             String         @unique
  adminId             String                   // The admin user who initiated
  impersonatedUserId  String                   // User being impersonated
  entrypoint          String                   // chat_start | guide_followup | followup | explain
  message             String         @db.Text  // The test message
  entityRefs          Json?                    // Optional entity references
  status              DebugRunStatus @default(pending)
  stoppedAtStage      String?                  // Stage where pipeline stopped
  errorMessage        String?

  // Settings stored for run continuation and raw access gating
  settings            Json                     // { includeRaw, runModel, providerOverrides }

  // Follow-up run support
  parentRunId          String?                 // Link to previous run in conversation chain
  conversationHistory  Json?                   // Persisted conversation [{role, content}]
  lastAssistantMessage String?       @db.Text  // Model response for chaining to next run

  admin               User           @relation("DebugRunAdmin", fields: [adminId], references: [id], onDelete: Restrict)
  impersonatedUser    User           @relation("DebugRunImpersonated", fields: [impersonatedUserId], references: [id], onDelete: Restrict)
  parentRun           DebugRun?      @relation("RunChain", fields: [parentRunId], references: [id], onDelete: SetNull)
  childRuns           DebugRun[]     @relation("RunChain")

  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt

  @@index([adminId, createdAt])
  @@index([runId])
  @@index([parentRunId])
}

// ---------- Rollups ----------

/// Canonical, auditable rollup snapshots (source of truth).
/// Used to answer: "What did we know when we recommended X?"
model UserRollup {
  userId         String
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// Rollup schema identifier, includes version (e.g. "forge.user_month_rollup_derived.v2")
  schema         String

  /// Inclusive window boundaries in UTC date space.
  windowStartUtc DateTime @db.Date
  windowEndUtc   DateTime @db.Date

  generatedAtUtc DateTime @default(now())

  /// Full rollup payload
  payload        Json

  /// Optional hash of payload for dedupe/debug
  payloadHash    String?

  /// Optional structured coverage metadata (timezone known/unknown, etc.)
  dataCoverage   Json?

  /// Optional retention / TTL marker
  expiresAt      DateTime?

  @@id([userId, windowEndUtc, schema])

  @@index([userId, windowEndUtc(sort: Desc)])
  @@index([userId, schema])
}